"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var core_1 = require("@angular/core");
var VortexStatusService_1 = require("./VortexStatusService");
var VortexService_1 = require("./VortexService");
var UtilMisc_1 = require("./UtilMisc");
var PayloadResponse_1 = require("./PayloadResponse");
var TupleStorageFactoryService_1 = require("./storage-factory/TupleStorageFactoryService");
var TupleActionPushOfflineSingletonService = (function () {
    function TupleActionPushOfflineSingletonService(vortexService, vortexStatus, factoryService) {
        var _this = this;
        this.vortexService = vortexService;
        this.vortexStatus = vortexStatus;
        this.sendingTuple = false;
        this.lastSendFailTime = null;
        this.SEND_FAIL_RETRY_TIMEOUT = 5000; // milliseconds
        this.SERVER_PROCESSING_TIMEOUT = 5000; // milliseconds
        this.SEND_FAIL_RETRY_BACKOFF = 5000; // milliseconds
        this.storage = factoryService.createActionStorage();
        // This is a global service, there is no point unsubscribing it
        this.vortexStatus.isOnline
            .filter(function (online) { return online === true; })
            .subscribe(function (online) { return _this.sendNextAction(); });
        this.storage.countActions()
            .then(function (count) {
            _this.vortexStatus.setQueuedActionCount(count);
        })
            .catch(function (err) {
            var errStr = UtilMisc_1.errToStr(err);
            var msg = "Failed to count actions : " + errStr;
            _this.vortexStatus.logError(msg);
        })
            .then(function () { return _this.sendNextAction(); });
    }
    TupleActionPushOfflineSingletonService.prototype.queueAction = function (scope, tupleAction, payload) {
        var _this = this;
        return this.storage.storeAction(scope, tupleAction, payload)
            .then(function () {
            _this.vortexStatus.incrementQueuedActionCount();
            _this.sendNextAction();
        })
            .catch(function (err) {
            var errStr = UtilMisc_1.errToStr(err);
            var msg = "Failed to store action : " + errStr;
            console.log(msg);
            throw new Error(msg);
        });
    };
    TupleActionPushOfflineSingletonService.prototype.sendNextAction = function () {
        var _this = this;
        if (this.sendingTuple)
            return;
        if (!this.vortexStatus.snapshot.isOnline)
            return;
        // Don't continually retry, if we have a last send fail, ensure we wait
        // {SEND_FAIL_RETRY_BACKOFF} before sending again.
        if (this.lastSendFailTime != null) {
            var reconnectDiffMs = Date.now() - this.lastSendFailTime;
            if (reconnectDiffMs < this.SEND_FAIL_RETRY_BACKOFF) {
                // +10ms to ensure we're just out of the backoff time.
                setTimeout(function () { return _this.sendNextAction(); }, this.SEND_FAIL_RETRY_BACKOFF - reconnectDiffMs + 10);
                return;
            }
            else {
                this.lastSendFailTime = null;
            }
        }
        this.sendingTuple = true;
        // Get the next tuple from the persistent queue
        this.storage.loadNextAction()
            .then(function (sendPayload) {
            // Is the end the end of the queue?
            if (sendPayload == null) {
                _this.sendingTuple = false;
                return;
            }
            var uuid = sendPayload.tuples[0].uuid;
            var scope = sendPayload.filt["name"];
            return new PayloadResponse_1.PayloadResponse(_this.vortexService, sendPayload, PayloadResponse_1.PayloadResponse.RESPONSE_TIMEOUT_SECONDS, // Timeout
            false // don't check result, only reject if it times out
            ).then(function (responsePayload) {
                // If we received a payload, but it has an error message
                // Log an error, it's out of our hands, move on.
                var r = responsePayload.result; // success is null or true
                if (!(r == null || r === true)) {
                    _this.vortexStatus.logError('Server failed to process Action: ' + responsePayload.result.toString());
                }
                _this.storage.deleteAction(scope, uuid).then(function () {
                    _this.vortexStatus.decrementQueuedActionCount();
                });
                _this.sendingTuple = false;
                _this.sendNextAction();
            });
        })
            .catch(function (err) {
            _this.lastSendFailTime = Date.now();
            var errStr = UtilMisc_1.errToStr(err);
            _this.vortexStatus.logError("Failed to send TupleAction : " + errStr);
            _this.sendingTuple = false;
            setTimeout(function () { return _this.sendNextAction(); }, _this.SEND_FAIL_RETRY_TIMEOUT);
            return null; // Handle the error
        });
    };
    TupleActionPushOfflineSingletonService = __decorate([
        core_1.Injectable(),
        __metadata("design:paramtypes", [VortexService_1.VortexService,
            VortexStatusService_1.VortexStatusService,
            TupleStorageFactoryService_1.TupleStorageFactoryService])
    ], TupleActionPushOfflineSingletonService);
    return TupleActionPushOfflineSingletonService;
}());
exports.TupleActionPushOfflineSingletonService = TupleActionPushOfflineSingletonService;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVHVwbGVBY3Rpb25QdXNoT2ZmbGluZVNpbmdsZXRvblNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJUdXBsZUFjdGlvblB1c2hPZmZsaW5lU2luZ2xldG9uU2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHNDQUF5QztBQUN6Qyw2REFBMEQ7QUFHMUQsaURBQThDO0FBQzlDLHVDQUFvQztBQUNwQyxxREFBa0Q7QUFDbEQsMkZBQXdGO0FBS3hGO0lBU0ksZ0RBQW9CLGFBQTRCLEVBQzVCLFlBQWlDLEVBQ3pDLGNBQTBDO1FBRnRELGlCQXFCQztRQXJCbUIsa0JBQWEsR0FBYixhQUFhLENBQWU7UUFDNUIsaUJBQVksR0FBWixZQUFZLENBQXFCO1FBUjdDLGlCQUFZLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLHFCQUFnQixHQUFrQixJQUFJLENBQUM7UUFFdkMsNEJBQXVCLEdBQUcsSUFBSSxDQUFDLENBQUEsZUFBZTtRQUM5Qyw4QkFBeUIsR0FBRyxJQUFJLENBQUMsQ0FBQSxlQUFlO1FBQ2hELDRCQUF1QixHQUFHLElBQUksQ0FBQyxDQUFDLGVBQWU7UUFNbkQsSUFBSSxDQUFDLE9BQU8sR0FBRyxjQUFjLENBQUMsbUJBQW1CLEVBQUUsQ0FBQztRQUVwRCwrREFBK0Q7UUFDL0QsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUFRO2FBQ3JCLE1BQU0sQ0FBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLE1BQU0sS0FBSyxJQUFJLEVBQWYsQ0FBZSxDQUFDO2FBQ2pDLFNBQVMsQ0FBQyxVQUFBLE1BQU0sSUFBSSxPQUFBLEtBQUksQ0FBQyxjQUFjLEVBQUUsRUFBckIsQ0FBcUIsQ0FBQyxDQUFDO1FBRWhELElBQUksQ0FBQyxPQUFPLENBQUMsWUFBWSxFQUFFO2FBQ3RCLElBQUksQ0FBQyxVQUFBLEtBQUs7WUFDUCxLQUFJLENBQUMsWUFBWSxDQUFDLG9CQUFvQixDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ2xELENBQUMsQ0FBQzthQUNE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LENBQUMsQ0FBQyxDQUFDO0lBQ1gsQ0FBQztJQXpIUSxzQ0FBc0M7UUFEbEQsaUJBQVUsRUFBRTt5Q0FVMEIsNkJBQWE7WUFDZCx5Q0FBbUI7WUFDekIsdURBQTBCO09BWDdDLHNDQUFzQyxDQTJIbEQ7SUFBRCw2Q0FBQztDQUFBLEFBM0hELElBMkhDO0FBM0hZLHdGQUFzQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7SW5qZWN0YWJsZX0gZnJvbSBcIkBhbmd1bGFyL2NvcmVcIjtcbmltcG9ydCB7Vm9ydGV4U3RhdHVzU2VydmljZX0gZnJvbSBcIi4vVm9ydGV4U3RhdHVzU2VydmljZVwiO1xuaW1wb3J0IHtUdXBsZUFjdGlvbkFCQ30gZnJvbSBcIi4vVHVwbGVBY3Rpb25cIjtcbmltcG9ydCB7UGF5bG9hZH0gZnJvbSBcIi4vUGF5bG9hZFwiO1xuaW1wb3J0IHtWb3J0ZXhTZXJ2aWNlfSBmcm9tIFwiLi9Wb3J0ZXhTZXJ2aWNlXCI7XG5pbXBvcnQge2VyclRvU3RyfSBmcm9tIFwiLi9VdGlsTWlzY1wiO1xuaW1wb3J0IHtQYXlsb2FkUmVzcG9uc2V9IGZyb20gXCIuL1BheWxvYWRSZXNwb25zZVwiO1xuaW1wb3J0IHtUdXBsZVN0b3JhZ2VGYWN0b3J5U2VydmljZX0gZnJvbSBcIi4vc3RvcmFnZS1mYWN0b3J5L1R1cGxlU3RvcmFnZUZhY3RvcnlTZXJ2aWNlXCI7XG5pbXBvcnQge1R1cGxlQWN0aW9uU3RvcmFnZVNlcnZpY2VBQkN9IGZyb20gXCIuL2FjdGlvbi1zdG9yYWdlL1R1cGxlQWN0aW9uU3RvcmFnZVNlcnZpY2VBQkNcIjtcblxuXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgVHVwbGVBY3Rpb25QdXNoT2ZmbGluZVNpbmdsZXRvblNlcnZpY2Uge1xuICAgIHByaXZhdGUgc3RvcmFnZTogVHVwbGVBY3Rpb25TdG9yYWdlU2VydmljZUFCQztcbiAgICBwcml2YXRlIHNlbmRpbmdUdXBsZSA9IGZhbHNlO1xuICAgIHByaXZhdGUgbGFzdFNlbmRGYWlsVGltZTogbnVsbCB8IG51bWJlciA9IG51bGw7XG5cbiAgICBwcml2YXRlIFNFTkRfRkFJTF9SRVRSWV9USU1FT1VUID0gNTAwMDsvLyBtaWxsaXNlY29uZHNcbiAgICBwcml2YXRlIFNFUlZFUl9QUk9DRVNTSU5HX1RJTUVPVVQgPSA1MDAwOy8vIG1pbGxpc2Vjb25kc1xuICAgIHByaXZhdGUgU0VORF9GQUlMX1JFVFJZX0JBQ0tPRkYgPSA1MDAwOyAvLyBtaWxsaXNlY29uZHNcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdm9ydGV4U2VydmljZTogVm9ydGV4U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIHZvcnRleFN0YXR1czogVm9ydGV4U3RhdHVzU2VydmljZSxcbiAgICAgICAgICAgICAgICBmYWN0b3J5U2VydmljZTogVHVwbGVTdG9yYWdlRmFjdG9yeVNlcnZpY2UpIHtcblxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSBmYWN0b3J5U2VydmljZS5jcmVhdGVBY3Rpb25TdG9yYWdlKCk7XG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGdsb2JhbCBzZXJ2aWNlLCB0aGVyZSBpcyBubyBwb2ludCB1bnN1YnNjcmliaW5nIGl0XG4gICAgICAgIHRoaXMudm9ydGV4U3RhdHVzLmlzT25saW5lXG4gICAgICAgICAgICAuZmlsdGVyKG9ubGluZSA9PiBvbmxpbmUgPT09IHRydWUpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKG9ubGluZSA9PiB0aGlzLnNlbmROZXh0QWN0aW9uKCkpO1xuXG4gICAgICAgIHRoaXMuc3RvcmFnZS5jb3VudEFjdGlvbnMoKVxuICAgICAgICAgICAgLnRoZW4oY291bnQgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudm9ydGV4U3RhdHVzLnNldFF1ZXVlZEFjdGlvbkNvdW50KGNvdW50KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyU3RyID0gZXJyVG9TdHIoZXJyKTtcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gYEZhaWxlZCB0byBjb3VudCBhY3Rpb25zIDogJHtlcnJTdHJ9YDtcbiAgICAgICAgICAgICAgICB0aGlzLnZvcnRleFN0YXR1cy5sb2dFcnJvcihtc2cpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuc2VuZE5leHRBY3Rpb24oKSk7XG4gICAgfVxuXG5cbiAgICBxdWV1ZUFjdGlvbihzY29wZTogc3RyaW5nLCB0dXBsZUFjdGlvbjogVHVwbGVBY3Rpb25BQkMsIHBheWxvYWQ6IFBheWxvYWQpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5zdG9yZUFjdGlvbihzY29wZSwgdHVwbGVBY3Rpb24sIHBheWxvYWQpXG4gICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52b3J0ZXhTdGF0dXMuaW5jcmVtZW50UXVldWVkQWN0aW9uQ291bnQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmROZXh0QWN0aW9uKCk7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBsZXQgZXJyU3RyID0gZXJyVG9TdHIoZXJyKTtcbiAgICAgICAgICAgICAgICBsZXQgbXNnID0gYEZhaWxlZCB0byBzdG9yZSBhY3Rpb24gOiAke2VyclN0cn1gO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwcml2YXRlIHNlbmROZXh0QWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5zZW5kaW5nVHVwbGUpXG4gICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgaWYgKCF0aGlzLnZvcnRleFN0YXR1cy5zbmFwc2hvdC5pc09ubGluZSlcbiAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAvLyBEb24ndCBjb250aW51YWxseSByZXRyeSwgaWYgd2UgaGF2ZSBhIGxhc3Qgc2VuZCBmYWlsLCBlbnN1cmUgd2Ugd2FpdFxuICAgICAgICAvLyB7U0VORF9GQUlMX1JFVFJZX0JBQ0tPRkZ9IGJlZm9yZSBzZW5kaW5nIGFnYWluLlxuICAgICAgICBpZiAodGhpcy5sYXN0U2VuZEZhaWxUaW1lICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxldCByZWNvbm5lY3REaWZmTXMgPSBEYXRlLm5vdygpIC0gdGhpcy5sYXN0U2VuZEZhaWxUaW1lO1xuXG4gICAgICAgICAgICBpZiAocmVjb25uZWN0RGlmZk1zIDwgdGhpcy5TRU5EX0ZBSUxfUkVUUllfQkFDS09GRikge1xuICAgICAgICAgICAgICAgIC8vICsxMG1zIHRvIGVuc3VyZSB3ZSdyZSBqdXN0IG91dCBvZiB0aGUgYmFja29mZiB0aW1lLlxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZW5kTmV4dEFjdGlvbigpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLlNFTkRfRkFJTF9SRVRSWV9CQUNLT0ZGIC0gcmVjb25uZWN0RGlmZk1zICsgMTApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZW5kRmFpbFRpbWUgPSBudWxsO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNlbmRpbmdUdXBsZSA9IHRydWU7XG5cbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IHR1cGxlIGZyb20gdGhlIHBlcnNpc3RlbnQgcXVldWVcbiAgICAgICAgdGhpcy5zdG9yYWdlLmxvYWROZXh0QWN0aW9uKClcblxuICAgICAgICAvLyBJZiB0aGlzIHdhcyBzdWNjZXNzZnVsP1xuICAgICAgICAgICAgLnRoZW4oKHNlbmRQYXlsb2FkOiBQYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhlIGVuZCB0aGUgZW5kIG9mIHRoZSBxdWV1ZT9cbiAgICAgICAgICAgICAgICBpZiAoc2VuZFBheWxvYWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRpbmdUdXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGV0IHV1aWQgPSAoPFR1cGxlQWN0aW9uQUJDPiBzZW5kUGF5bG9hZC50dXBsZXNbMF0pLnV1aWQ7XG4gICAgICAgICAgICAgICAgbGV0IHNjb3BlID0gc2VuZFBheWxvYWQuZmlsdFtcIm5hbWVcIl07XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFBheWxvYWRSZXNwb25zZSh0aGlzLnZvcnRleFNlcnZpY2UsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBQYXlsb2FkUmVzcG9uc2UuUkVTUE9OU0VfVElNRU9VVF9TRUNPTkRTLCAvLyBUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIGZhbHNlIC8vIGRvbid0IGNoZWNrIHJlc3VsdCwgb25seSByZWplY3QgaWYgaXQgdGltZXMgb3V0XG4gICAgICAgICAgICAgICAgKS50aGVuKHJlc3BvbnNlUGF5bG9hZCA9PiB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlY2VpdmVkIGEgcGF5bG9hZCwgYnV0IGl0IGhhcyBhbiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIC8vIExvZyBhbiBlcnJvciwgaXQncyBvdXQgb2Ygb3VyIGhhbmRzLCBtb3ZlIG9uLlxuICAgICAgICAgICAgICAgICAgICBsZXQgciA9IHJlc3BvbnNlUGF5bG9hZC5yZXN1bHQ7IC8vIHN1Y2Nlc3MgaXMgbnVsbCBvciB0cnVlXG4gICAgICAgICAgICAgICAgICAgIGlmICghKHIgPT0gbnVsbCB8fCByID09PSB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy52b3J0ZXhTdGF0dXMubG9nRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ1NlcnZlciBmYWlsZWQgdG8gcHJvY2VzcyBBY3Rpb246ICcgKyByZXNwb25zZVBheWxvYWQucmVzdWx0LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9yYWdlLmRlbGV0ZUFjdGlvbihzY29wZSwgdXVpZCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnZvcnRleFN0YXR1cy5kZWNyZW1lbnRRdWV1ZWRBY3Rpb25Db3VudCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kaW5nVHVwbGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZW5kTmV4dEFjdGlvbigpO1xuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgIC8vIE9yIGNhdGNoIGFuZCBoYW5kbGUgYW55IG9mIHRoZSBlcnJvcnMgZnJvbSBlaXRoZXIgbG9hZGluZyBvciBzZW5kaW5nXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZW5kRmFpbFRpbWUgPSBEYXRlLm5vdygpO1xuXG4gICAgICAgICAgICAgICAgbGV0IGVyclN0ciA9IGVyclRvU3RyKGVycik7XG4gICAgICAgICAgICAgICAgdGhpcy52b3J0ZXhTdGF0dXMubG9nRXJyb3IoXG4gICAgICAgICAgICAgICAgICAgIGBGYWlsZWQgdG8gc2VuZCBUdXBsZUFjdGlvbiA6ICR7ZXJyU3RyfWBcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZGluZ1R1cGxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbmROZXh0QWN0aW9uKCksIHRoaXMuU0VORF9GQUlMX1JFVFJZX1RJTUVPVVQpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBIYW5kbGUgdGhlIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbn1cblxuIl19